# -*- coding: utf-8 -*-
"""House Price.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AHvMQdKrqA9BD_5bx1zqzzx11dxjxEDg
"""

import pandas as pd
import seaborn as sns
import altair as alt

from sklearn.model_selection import train_test_split
from sklearn import metrics
from matplotlib import pyplot as plt
from xgboost import XGBClassifier
from xgboost import XGBRegressor
from xgboost import plot_importance
from xgboost import plot_tree

housing=pd.read_csv("https://raw.githubusercontent.com/byui-cse/cse450-course/master/data/housing.csv")
housing.info()

#Change date datatype
housing['date'] = pd.to_datetime(housing['date'])

"""Feature Engineering Ideas:
*   total_property_sqft = sqft_lot +sqft_living
*   sqft_dif_neighbors = sqft_living - sqft_living15
"""

#new features
housing['age_renovation'] = 0

housing['age_renovation'] == 0
for i in range(len(housing)):
    if housing['yr_renovated'].iloc[i] == 0:
        housing['age_renovation'].iloc[i] = 0
    else:
        housing['age_renovation'].iloc[i] = housing['yr_renovated'].iloc[i] - housing['yr_built'].iloc[i]

#new feature
housing['total_property_sqft_dif_of_neighbors'] = (housing['sqft_lot'] + housing['sqft_living']) - (housing['sqft_living15'] + housing['sqft_lot15'])
housing['was_renovated'] = housing['yr_renovated'].apply(lambda x: 0 if x == 0 else 1)
housing['quality_opinion'] = ((housing['view'] + housing['condition'] + housing['grade']) / (4 + 5 + 13))

#heatmap

# correlation matrix helps us see what features are related and by how much.
corr_matrix = housing.corr()
# visualize the correlation matrix
fig, ax = plt.subplots(figsize=(20, 18))
hm = sns.heatmap(corr_matrix, annot=True)
hm.set_title("Correlation Heatmap of Housing Data")
plt.show()

#XGBoost model

median_income = {
    98038: 68180,
    98023 : 57411,
    98116 : 54563,
    98117 : 55777,
    98034 : 60043,
    98065 : 60658,
    98031 : 50958,
    98075 : None,
    98028 : 61813,
    98103 : 49044,
    98004 : 63358,
    98166 : 50310,
    98077 : None,
    98008 : None,
    98006 : 81929,
    98199 : 59542,
    98052 : 68923,
    98136 : 56455,
    98108 : 38413,
    98055 : 42758,
    98027 : 70085,
    98058 : 63680,
    98144 : 40693,
    98115 : 58475,
    98168 : 41097,
    98102 : 41850,
    98042 : 66051,
    98059 : 61361,
    98002 : 36991,
    98155 : 55863,
    98072 : 82922,
    98001 : 60534,
    98112 : 59693,
    98007 : 48606,
    98177 : 65514,
    98074 : None,
    98119 : 49222,
    98011 : 61329,
    98014 : 66841,
    98106 : 40815,
    98045 : 65674,
    98033 : 69073,
    98125 : 42400,
    98133 : 41743,
    98053 : 96028,
    98122 : 32085,
    98178 : 47461,
    98148 : 37411,
    98019 : 72438,
    98010 : 66709,
    98070 : 58261,
    98056 : 53608,
    98030 : None,
    98188 : 40618,
    98029 : 91146,
    98107 : 42195,
    98105 : 40246,
    98198 : 46628,
    98003 : 43027,
    98118 : 44697,
    98126 : 47519,
    98040 : 91904,
    98092 : 62478,
    98032 : 42042,
    98146 : 46321,
    98024 : 62076,
    98005 : 60173,
    98039 : 132665,
    98109 : 49531,
    98022 : 54118
}
def get_median_income(zipcode):
  if median_income[int(zipcode)] == None:
    return 58000
  else:
    return median_income[int(zipcode)]
housing['median_income'] = (housing["zipcode"]).apply(get_median_income)

housing['total_property_sqft_dif_of_neighbors'] = (housing['sqft_lot'] + housing['sqft_living']) - (housing['sqft_living15'] + housing['sqft_lot15'])
housing['was_renovated'] = housing['yr_renovated'].apply(lambda x: 0 if x == 0 else 1)

housing['age_renovation'] = 0
housing['age_renovation'] == 0
for i in range(len(housing)):
    if housing['yr_renovated'].iloc[i] == 0:
        housing['age_renovation'].iloc[i] = 0
    else:
        housing['age_renovation'].iloc[i] = housing['yr_renovated'].iloc[i] - housing['yr_built'].iloc[i]

housing['quality_opinion'] = ((housing['view'] + housing['condition'] + housing['grade']) / (4 + 5 + 13))

import datetime
cur_date = datetime.date.today()
cur_year = cur_date.year
housing['age_of_house'] = cur_year - housing['yr_built']

#xgboost model
features = ['bedrooms', 'bathrooms', 'sqft_living', 'sqft_lot','floors', 'waterfront', 'view',
            'condition', 'grade', 'sqft_above','sqft_basement', 'yr_built', 'yr_renovated', 'zipcode', 'lat',
            'long','sqft_living15', 'sqft_lot15','age_renovation','median_income','quality_opinion',
            'age_of_house','total_property_sqft_dif_of_neighbors','was_renovated']
X = housing[features]
y = housing['price']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create the model and train it
model = XGBRegressor(seed=20,colsample_bytree=0.7, learning_rate=0.05, max_depth=6, n_estimators=500)
model.fit(X_train, y_train)

# Get predictions for test data
predictions = model.predict(X_test)
predictions

# Perform cross-validation
scores = cross_val_score(model, X, y, cv=5, scoring='neg_mean_squared_error')

# Compute the Root Mean Squared Error of the predictions
from sklearn.metrics import mean_squared_error
import numpy as np

# Calculate evaluation metrics
mae = metrics.mean_absolute_error(y_test, predictions)
mse = metrics.mean_squared_error(y_test, predictions)
rmse = np.sqrt(mse)
r2 = metrics.r2_score(y_test, predictions)

# Print the metrics
print(f"Mean Absolute Error (MAE):, {mae:,.0f}")
print(f"Mean Squared Error (MSE):  {mse:,.0f}")
print(f"Root Mean Squared Error (RMSE): {rmse:,.0f}")
print(f"R-squared (R2):  {r2:.2f}")

# Mean Absolute Error (MAE):, 65,660
# Mean Squared Error (MSE):  15,515,216,848
# Root Mean Squared Error (RMSE): 124,560
# R-squared (R2):  0.90
# Mini R2: 0.9045422758325913

holdout = pd.read_csv("https://raw.githubusercontent.com/byui-cse/cse450-course/master/data/housing_holdout_test.csv")

# mini['dist_to_seattle'] = mini.apply(lambda row: haversine(row['long'], row['lat']), axis=1)
holdout['total_property_sqft_dif_of_neighbors'] = (holdout['sqft_lot'] + holdout['sqft_living']) - (holdout['sqft_living15'] + holdout['sqft_lot15'])
holdout['was_renovated'] = holdout['yr_renovated'].apply(lambda x: 0 if x == 0 else 1)

holdout['age_renovation'] = 0
holdout['age_renovation'] == 0
for i in range(len(holdout)):
    if holdout['yr_renovated'].iloc[i] == 0:
        holdout['age_renovation'].iloc[i] = 0
    else:
        holdout['age_renovation'].iloc[i] = holdout['yr_renovated'].iloc[i] - holdout['yr_built'].iloc[i]

holdout['quality_opinion'] = ((holdout['view'] + holdout['condition'] + holdout['grade']) / (4 + 5 + 13))
holdout['median_income'] = (holdout["zipcode"]).apply(get_median_income)

import datetime
cur_date = datetime.date.today()
cur_year = cur_date.year
holdout['age_of_house'] = cur_year - holdout['yr_built']

predict_X = holdout[features]
predicted_y = model.predict(predict_X)
predicted_data = pd.DataFrame(predicted_y, columns=['price'])

# from google.colab import files
# predicted_data.to_csv("predictions-final.csv", index=False)
# files.download("predictions-final.csv")

# compare to Random Forest Regression
# Import Random Forest Regressor
from sklearn.ensemble import RandomForestRegressor

housing['total_property_sqft_dif_of_neighbors'] = (housing['sqft_lot'] + housing['sqft_living']) - (housing['sqft_living15'] + housing['sqft_lot15'])
housing['was_renovated'] = housing['yr_renovated'].apply(lambda x: 0 if x == 0 else 1)

housing['age_renovation'] = 0
housing['age_renovation'] == 0
for i in range(len(housing)):
    if housing['yr_renovated'].iloc[i] == 0:
        housing['age_renovation'].iloc[i] = 0
    else:
        housing['age_renovation'].iloc[i] = housing['yr_renovated'].iloc[i] - housing['yr_built'].iloc[i]

housing['quality_opinion'] = ((housing['view'] + housing['condition'] + housing['grade']) / (4 + 5 + 13))

import datetime
cur_date = datetime.date.today()
cur_year = cur_date.year
housing['age_of_house'] = cur_year - housing['yr_built']

features = ['bedrooms', 'bathrooms', 'sqft_living', 'sqft_lot','floors', 'waterfront', 'view',
            'condition', 'grade', 'sqft_above','sqft_basement', 'yr_built', 'yr_renovated', 'zipcode', 'lat',
            'long','sqft_living15', 'sqft_lot15','total_property_sqft_dif_of_neighbors',
            'age_renovation','age_of_house','quality_opinion','median_income','was_renovated']
X = housing[features]
y = housing['price']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create a Random Forest Regressor
reg = RandomForestRegressor(max_depth=30, random_state=42)

# Train the model using the training sets
reg.fit(X_train, y_train)

# Model prediction on train data
y_pred = reg.predict(X_train)

# Model Evaluation
print(f"Mean Absolute Error (MAE):, {mae:,.0f}")
print(f"Mean Squared Error (MSE):  {mse:,.0f}")
print(f"Root Mean Squared Error (RMSE): {rmse:,.0f}")
print(f"R-squared (R2):  {r2:.2f}")

# Mean Absolute Error (MAE):, 65,660
# Mean Squared Error (MSE):  15,515,216,848
# Root Mean Squared Error (RMSE): 124,560
# R-squared (R2):  0.90
# Mini R2: 0.8223492958557659